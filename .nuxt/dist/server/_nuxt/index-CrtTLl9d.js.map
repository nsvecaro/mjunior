{"version":3,"file":"index-CrtTLl9d.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/@nuxt/icon/dist/runtime/components/shared.js","../../../../node_modules/@nuxt/icon/dist/runtime/components/css.js","../../../../node_modules/@nuxt/icon/dist/runtime/components/svg.js","../../../../node_modules/@nuxt/icon/dist/runtime/components/index.js"],"sourcesContent":["import { computed, getCurrentInstance, getCurrentScope, inject, isShallow, nextTick, onBeforeMount, onScopeDispose, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, toValue, unref, watch } from \"vue\";\nimport { captureStackTrace } from \"errx\";\nimport { debounce } from \"perfect-debounce\";\nimport { hash } from \"ohash\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { clientOnlySymbol } from \"../components/client-only.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults, granularCachedData, pendingWhenIdle, purgeCachedData, resetAsyncDataToUndefined } from \"#build/nuxt.config.mjs\";\nconst isDefer = (dedupe) => dedupe === \"defer\" || dedupe === false;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  let [_key, _handler, options = {}] = args;\n  const key = computed(() => toValue(_key));\n  if (typeof key.value !== \"string\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] key must be a string.\");\n  }\n  if (typeof _handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [useAsyncData] handler must be a function.\");\n  }\n  const nuxtApp = useNuxtApp();\n  options.server ??= true;\n  options.default ??= getDefault;\n  options.getCachedData ??= getDefaultCachedData;\n  options.lazy ??= false;\n  options.immediate ??= true;\n  options.deep ??= asyncDataDefaults.deep;\n  options.dedupe ??= \"cancel\";\n  const functionName = options._functionName || \"useAsyncData\";\n  if (import.meta.dev && typeof options.dedupe === \"boolean\") {\n    console.warn(`[nuxt] \\`boolean\\` values are deprecated for the \\`dedupe\\` option of \\`${functionName}\\` and will be removed in the future. Use 'cancel' or 'defer' instead.`);\n  }\n  const currentData = nuxtApp._asyncData[key.value];\n  if (isDev && currentData) {\n    const warnings = [];\n    const values = createHash(_handler, options);\n    if (values.handler !== currentData._hash?.handler) {\n      warnings.push(`different handler`);\n    }\n    for (const opt of [\"transform\", \"pick\", \"getCachedData\"]) {\n      if (values[opt] !== currentData._hash[opt]) {\n        warnings.push(`different \\`${opt}\\` option`);\n      }\n    }\n    if (currentData._default.toString() !== options.default.toString()) {\n      warnings.push(`different \\`default\\` value`);\n    }\n    if (options.deep && isShallow(currentData.data)) {\n      warnings.push(`mismatching \\`deep\\` option`);\n    }\n    if (warnings.length) {\n      const distURL = import.meta.url.replace(/\\/app\\/.*$/, \"/app\");\n      const { source, line, column } = captureStackTrace().find((entry) => !entry.source.startsWith(distURL)) ?? {};\n      const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n      console.warn(`[nuxt] [${functionName}] Incompatible options detected for \"${key.value}\"${explanation}:\n${warnings.map((w) => `- ${w}`).join(\"\\n\")}\nYou can use a different key or move the call to a composable to ensure the options are shared across calls.`);\n    }\n  }\n  const initialFetchOptions = { cause: \"initial\", dedupe: options.dedupe };\n  if (!nuxtApp._asyncData[key.value]?._init) {\n    initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: \"initial\" });\n    nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);\n  }\n  const asyncData = nuxtApp._asyncData[key.value];\n  asyncData._deps++;\n  const initialFetch = () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);\n  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxtApp.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    let unregister = function(key2) {\n      const data = nuxtApp._asyncData[key2];\n      if (data?._deps) {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      }\n    };\n    const instance = getCurrentInstance();\n    if (instance && fetchOnServer && options.immediate && !instance.sp) {\n      instance.sp = [];\n    }\n    if (import.meta.dev && !nuxtApp.isHydrating && !nuxtApp._processingMiddleware && (!instance || instance?.isMounted)) {\n      console.warn(`[nuxt] [${functionName}] Component is already mounted, please use $fetch instead. See https://nuxt.com/docs/getting-started/data-fetching`);\n    }\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      onBeforeMount(() => {\n        cbs.forEach((cb) => {\n          cb();\n        });\n        cbs.splice(0, cbs.length);\n      });\n      onUnmounted(() => cbs.splice(0, cbs.length));\n    }\n    const isWithinClientOnly = instance && (instance._nuxtClientOnly || inject(clientOnlySymbol, false));\n    if (fetchOnServer && nuxtApp.isHydrating && (asyncData.error.value || asyncData.data.value != null)) {\n      if (pendingWhenIdle) {\n        asyncData.pending.value = false;\n      }\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (!isWithinClientOnly && nuxtApp.payload.serverRendered && nuxtApp.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    const hasScope = getCurrentScope();\n    const unsubExecute = watch([key, ...options.watch || []], ([newKey], [oldKey]) => {\n      if ((newKey || oldKey) && newKey !== oldKey) {\n        const hasRun = nuxtApp._asyncData[oldKey]?.data.value !== asyncDataDefaults.value;\n        const isRunning = nuxtApp._asyncDataPromises[oldKey] !== void 0;\n        if (oldKey) {\n          unregister(oldKey);\n        }\n        const initialFetchOptions2 = { cause: \"initial\", dedupe: options.dedupe };\n        if (!nuxtApp._asyncData[newKey]?._init) {\n          initialFetchOptions2.cachedData = options.getCachedData(newKey, nuxtApp, { cause: \"initial\" });\n          nuxtApp._asyncData[newKey] = createAsyncData(nuxtApp, newKey, _handler, options, initialFetchOptions2.cachedData);\n        }\n        nuxtApp._asyncData[newKey]._deps++;\n        if (options.immediate || hasRun || isRunning) {\n          nuxtApp._asyncData[newKey].execute(initialFetchOptions2);\n        }\n      } else {\n        asyncData._execute({ cause: \"watch\", dedupe: options.dedupe });\n      }\n    }, { flush: \"sync\" });\n    if (hasScope) {\n      onScopeDispose(() => {\n        unsubExecute();\n        unregister(key.value);\n      });\n    }\n  }\n  const asyncReturn = {\n    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),\n    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),\n    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),\n    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),\n    refresh: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    execute: (...args2) => nuxtApp._asyncData[key.value].execute(...args2),\n    clear: () => clearNuxtDataByKey(nuxtApp, key.value)\n  };\n  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);\n  Object.assign(asyncDataPromise, asyncReturn);\n  return asyncDataPromise;\n}\nfunction writableComputedRef(getter) {\n  return computed({\n    get() {\n      return getter()?.value;\n    },\n    set(value) {\n      const ref2 = getter();\n      if (ref2) {\n        ref2.value = value;\n      }\n    }\n  });\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (_isAutoKeyNeeded(args[0], args[1])) {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options = {}] = args;\n  if (import.meta.dev) {\n    options._functionName ||= \"useLazyAsyncData\";\n  }\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nfunction _isAutoKeyNeeded(keyOrFetcher, fetcher) {\n  if (typeof keyOrFetcher === \"string\") {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"object\" && keyOrFetcher !== null) {\n    return false;\n  }\n  if (typeof keyOrFetcher === \"function\" && typeof fetcher === \"function\") {\n    return false;\n  }\n  return true;\n}\nexport function useNuxtData(key) {\n  const nuxtApp = useNuxtApp();\n  if (!(key in nuxtApp.payload.data)) {\n    nuxtApp.payload.data[key] = asyncDataDefaults.value;\n  }\n  if (nuxtApp._asyncData[key]) {\n    const data = nuxtApp._asyncData[key];\n    data._deps++;\n    if (getCurrentScope()) {\n      onScopeDispose(() => {\n        data._deps--;\n        if (data._deps === 0) {\n          data?._off();\n        }\n      });\n    }\n  }\n  return {\n    data: computed({\n      get() {\n        return nuxtApp._asyncData[key]?.data.value ?? nuxtApp.payload.data[key];\n      },\n      set(value) {\n        if (nuxtApp._asyncData[key]) {\n          nuxtApp._asyncData[key].data.value = value;\n        } else {\n          nuxtApp.payload.data[key] = value;\n        }\n      }\n    })\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? toArray(keys) : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const key of _keys) {\n    clearNuxtDataByKey(nuxtApp, key);\n  }\n}\nfunction clearNuxtDataByKey(nuxtApp, key) {\n  if (key in nuxtApp.payload.data) {\n    nuxtApp.payload.data[key] = void 0;\n  }\n  if (key in nuxtApp.payload._errors) {\n    nuxtApp.payload._errors[key] = asyncDataDefaults.errorValue;\n  }\n  if (nuxtApp._asyncData[key]) {\n    nuxtApp._asyncData[key].data.value = resetAsyncDataToUndefined ? void 0 : unref(nuxtApp._asyncData[key]._default());\n    nuxtApp._asyncData[key].error.value = asyncDataDefaults.errorValue;\n    if (pendingWhenIdle) {\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    nuxtApp._asyncData[key].status.value = \"idle\";\n  }\n  if (key in nuxtApp._asyncDataPromises) {\n    if (nuxtApp._asyncDataPromises[key]) {\n      nuxtApp._asyncDataPromises[key].cancelled = true;\n    }\n    nuxtApp._asyncDataPromises[key] = void 0;\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\nconst isDev = import.meta.dev;\nfunction createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {\n  nuxtApp.payload._errors[key] ??= asyncDataDefaults.errorValue;\n  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;\n  const handler = import.meta.client || !import.meta.prerender || !nuxtApp.ssrContext?._sharedPrerenderCache ? _handler : () => {\n    const value = nuxtApp.ssrContext._sharedPrerenderCache.get(key);\n    if (value) {\n      return value;\n    }\n    const promise = Promise.resolve().then(() => nuxtApp.runWithContext(() => _handler(nuxtApp)));\n    nuxtApp.ssrContext._sharedPrerenderCache.set(key, promise);\n    return promise;\n  };\n  const _ref = options.deep ? ref : shallowRef;\n  const hasCachedData = initialCachedData != null;\n  const unsubRefreshAsyncData = nuxtApp.hook(\"app:data:refresh\", async (keys) => {\n    if (!keys || keys.includes(key)) {\n      await asyncData.execute({ cause: \"refresh:hook\" });\n    }\n  });\n  const asyncData = {\n    data: _ref(hasCachedData ? initialCachedData : options.default()),\n    pending: pendingWhenIdle ? shallowRef(!hasCachedData) : computed(() => asyncData.status.value === \"pending\"),\n    error: toRef(nuxtApp.payload._errors, key),\n    status: shallowRef(\"idle\"),\n    execute: (...args) => {\n      const [_opts, newValue = void 0] = args;\n      const opts = _opts && newValue === void 0 && typeof _opts === \"object\" ? _opts : {};\n      if (import.meta.dev && newValue !== void 0 && (!_opts || typeof _opts !== \"object\")) {\n        console.warn(`[nuxt] [${options._functionName}] Do not pass \\`execute\\` directly to \\`watch\\`. Instead, use an inline function, such as \\`watch(q, () => execute())\\`.`);\n      }\n      if (nuxtApp._asyncDataPromises[key]) {\n        if (isDefer(opts.dedupe ?? options.dedupe)) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        nuxtApp._asyncDataPromises[key].cancelled = true;\n      }\n      if (granularCachedData || opts.cause === \"initial\" || nuxtApp.isHydrating) {\n        const cachedData = \"cachedData\" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? \"refresh:manual\" });\n        if (cachedData != null) {\n          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;\n          asyncData.error.value = asyncDataDefaults.errorValue;\n          asyncData.status.value = \"success\";\n          return Promise.resolve(cachedData);\n        }\n      }\n      if (pendingWhenIdle) {\n        asyncData.pending.value = true;\n      }\n      asyncData.status.value = \"pending\";\n      const promise = new Promise(\n        (resolve, reject) => {\n          try {\n            resolve(handler(nuxtApp));\n          } catch (err) {\n            reject(err);\n          }\n        }\n      ).then(async (_result) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        let result = _result;\n        if (options.transform) {\n          result = await options.transform(_result);\n        }\n        if (options.pick) {\n          result = pick(result, options.pick);\n        }\n        if (import.meta.dev && import.meta.server && result == null) {\n          const stack = captureStackTrace();\n          const { source, line, column } = stack[stack.length - 1] ?? {};\n          const explanation = source ? ` (used at ${source.replace(/^file:\\/\\//, \"\")}:${line}:${column})` : \"\";\n          console.warn(`[nuxt] \\`${options._functionName || \"useAsyncData\"}${explanation}\\` must return a value (it should not be \\`undefined\\` or \\`null\\`) or the request may be duplicated on the client side.`);\n        }\n        nuxtApp.payload.data[key] = result;\n        asyncData.data.value = result;\n        asyncData.error.value = asyncDataDefaults.errorValue;\n        asyncData.status.value = \"success\";\n      }).catch((error) => {\n        if (promise.cancelled) {\n          return nuxtApp._asyncDataPromises[key];\n        }\n        asyncData.error.value = createError(error);\n        asyncData.data.value = unref(options.default());\n        asyncData.status.value = \"error\";\n      }).finally(() => {\n        if (promise.cancelled) {\n          return;\n        }\n        if (pendingWhenIdle) {\n          asyncData.pending.value = false;\n        }\n        delete nuxtApp._asyncDataPromises[key];\n      });\n      nuxtApp._asyncDataPromises[key] = promise;\n      return nuxtApp._asyncDataPromises[key];\n    },\n    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),\n    _default: options.default,\n    _deps: 0,\n    _init: true,\n    _hash: isDev ? createHash(_handler, options) : void 0,\n    _off: () => {\n      unsubRefreshAsyncData();\n      if (nuxtApp._asyncData[key]?._init) {\n        nuxtApp._asyncData[key]._init = false;\n      }\n      if (purgeCachedData && !hasCustomGetCachedData) {\n        nextTick(() => {\n          if (!nuxtApp._asyncData[key]?._init) {\n            clearNuxtDataByKey(nuxtApp, key);\n            asyncData.execute = () => Promise.resolve();\n            asyncData.data.value = asyncDataDefaults.value;\n          }\n        });\n      }\n    }\n  };\n  return asyncData;\n}\nconst getDefault = () => asyncDataDefaults.value;\nconst getDefaultCachedData = (key, nuxtApp, ctx) => {\n  if (nuxtApp.isHydrating) {\n    return nuxtApp.payload.data[key];\n  }\n  if (ctx.cause !== \"refresh:manual\" && ctx.cause !== \"refresh:hook\") {\n    return nuxtApp.static.data[key];\n  }\n};\nfunction createHash(_handler, options) {\n  return {\n    handler: hash(_handler),\n    transform: options.transform ? hash(options.transform) : void 0,\n    pick: options.pick ? hash(options.pick) : void 0,\n    getCachedData: options.getCachedData ? hash(options.getCachedData) : void 0\n  };\n}\n","import { computed } from \"vue\";\nimport { getIcon as _getIcon, addIcon as _addIcon, loadIcon as _loadIcon } from \"@iconify/vue\";\nimport { useAppConfig } from \"#imports\";\nimport { init as initClientBundle } from \"#build/nuxt-icon-client-bundle\";\nexport { initClientBundle };\nexport async function loadIcon(name, timeout) {\n  if (!name)\n    return null;\n  initClientBundle(_addIcon);\n  const _icon = _getIcon(name);\n  if (_icon)\n    return _icon;\n  let timeoutWarn;\n  const load = _loadIcon(name).catch(() => {\n    console.warn(`[Icon] failed to load icon \\`${name}\\``);\n    return null;\n  });\n  if (timeout > 0)\n    await Promise.race([\n      load,\n      new Promise((resolve) => {\n        timeoutWarn = setTimeout(() => {\n          console.warn(`[Icon] loading icon \\`${name}\\` timed out after ${timeout}ms`);\n          resolve();\n        }, timeout);\n      })\n    ]).finally(() => clearTimeout(timeoutWarn));\n  else\n    await load;\n  return _getIcon(name);\n}\nexport function useResolvedName(getName) {\n  const options = useAppConfig().icon;\n  const collections = (options.collections || []).sort((a, b) => b.length - a.length);\n  return computed(() => {\n    const name = getName();\n    const bare = name.startsWith(options.cssSelectorPrefix) ? name.slice(options.cssSelectorPrefix.length) : name;\n    const resolved = options.aliases?.[bare] || bare;\n    if (!resolved.includes(\":\")) {\n      const collection = collections.find((c) => resolved.startsWith(c + \"-\"));\n      return collection ? collection + \":\" + resolved.slice(collection.length + 1) : resolved;\n    }\n    return resolved;\n  });\n}\nexport function resolveCustomizeFn(customize, globalCustomize) {\n  if (customize === false) return void 0;\n  if (customize === true || customize === null) return globalCustomize;\n  return customize;\n}\n","import { addIcon, getIcon as _getIcon } from \"@iconify/vue\";\nimport { computed, watch, h, defineComponent } from \"vue\";\nimport { getIconCSS } from \"@iconify/utils/lib/css/icon\";\nimport { loadIcon, resolveCustomizeFn } from \"./shared.js\";\nimport { useAppConfig, useNuxtApp, useHead, useRuntimeConfig, onServerPrefetch } from \"#imports\";\nlet cssSelectors;\nconst SYMBOL_SERVER_CSS = \"NUXT_ICONS_SERVER_CSS\";\nfunction escapeCssSelector(selector) {\n  return selector.replace(/([^\\w-])/g, \"\\\\$1\");\n}\nfunction getAllSelectors() {\n  if (cssSelectors)\n    return cssSelectors;\n  cssSelectors = /* @__PURE__ */ new Set();\n  const filter = (selector) => {\n    selector = selector.replace(/^:where\\((.*)\\)$/, \"$1\").trim();\n    if (selector.startsWith(\".\")) {\n      return selector;\n    }\n  };\n  const scanCssRules = (rules) => {\n    if (!rules?.length)\n      return;\n    for (const rule of rules) {\n      if (rule?.cssRules) {\n        scanCssRules(rule.cssRules);\n      }\n      const selectorRaw = rule?.selectorText;\n      if (typeof selectorRaw === \"string\") {\n        const selector = filter(selectorRaw);\n        if (selector)\n          cssSelectors.add(selector);\n      }\n    }\n  };\n  if (typeof document !== \"undefined\") {\n    for (const styleSheet of document.styleSheets) {\n      try {\n        const rules = styleSheet.cssRules || styleSheet.rules;\n        scanCssRules(rules);\n      } catch {\n      }\n    }\n  }\n  return cssSelectors;\n}\nexport const NuxtIconCss = /* @__PURE__ */ defineComponent({\n  name: \"NuxtIconCss\",\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    customize: {\n      type: [Function, Boolean, null],\n      default: null,\n      required: false\n    }\n  },\n  setup(props) {\n    const nuxt = useNuxtApp();\n    const options = useAppConfig().icon;\n    const cssClass = computed(() => props.name ? options.cssSelectorPrefix + props.name : \"\");\n    function getIcon(name) {\n      if (!name)\n        return;\n      const icon = _getIcon(name);\n      if (icon)\n        return icon;\n      const payload = nuxt.payload?.data?.[name];\n      if (payload) {\n        addIcon(name, payload);\n        return payload;\n      }\n    }\n    const selector = computed(() => \".\" + escapeCssSelector(cssClass.value));\n    function getCSS(icon, withLayer = true) {\n      let iconSelector = selector.value;\n      if (options.cssWherePseudo) {\n        iconSelector = `:where(${iconSelector})`;\n      }\n      const css = getIconCSS(icon, {\n        iconSelector,\n        format: \"compressed\",\n        customise: resolveCustomizeFn(props.customize, options.customize)\n      });\n      if (options.cssLayer && withLayer) {\n        return `@layer ${options.cssLayer} { ${css} }`;\n      }\n      return css;\n    }\n    if (import.meta.client) {\n      const selectors = getAllSelectors();\n      async function mountCSS(icon) {\n        if (selectors.has(selector.value))\n          return;\n        if (typeof document === \"undefined\")\n          return;\n        const style = document.createElement(\"style\");\n        style.textContent = getCSS(icon);\n        if (import.meta.dev) {\n          style.dataset.nuxtIconDev = props.name;\n        }\n        const firstStyle = document.head.querySelector('style, link[rel=\"stylesheet\"]');\n        if (firstStyle)\n          document.head.insertBefore(style, firstStyle);\n        else\n          document.head.appendChild(style);\n        selectors.add(selector.value);\n      }\n      watch(\n        () => props.name,\n        () => {\n          if (selectors.has(selector.value)) {\n            return;\n          }\n          const data = getIcon(props.name);\n          if (data) {\n            mountCSS(data);\n          } else {\n            loadIcon(props.name, import.meta.server ? options.fetchTimeout : -1).then((data2) => {\n              if (data2)\n                mountCSS(data2);\n            }).catch(() => null);\n          }\n        },\n        { immediate: true }\n      );\n    }\n    onServerPrefetch(async () => {\n      if (import.meta.server) {\n        const configs = useRuntimeConfig().icon || {};\n        if (!configs?.serverKnownCssClasses?.includes(cssClass.value)) {\n          const icon = await loadIcon(props.name, options.fetchTimeout).catch(() => null);\n          if (!icon)\n            return null;\n          let ssrCSS = nuxt.vueApp._context.provides[SYMBOL_SERVER_CSS];\n          if (!ssrCSS) {\n            ssrCSS = nuxt.vueApp._context.provides[SYMBOL_SERVER_CSS] = /* @__PURE__ */ new Map();\n            nuxt.runWithContext(() => {\n              useHead({\n                style: [\n                  () => {\n                    const sep = import.meta.dev ? \"\\n\" : \"\";\n                    let css = Array.from(ssrCSS.values()).sort().join(sep);\n                    if (options.cssLayer) {\n                      css = `@layer ${options.cssLayer} {${sep}${css}${sep}}`;\n                    }\n                    return { innerHTML: css };\n                  }\n                ]\n              }, {\n                tagPriority: \"low\"\n              });\n            });\n          }\n          if (props.name && !ssrCSS.has(props.name)) {\n            const css = getCSS(icon, false);\n            ssrCSS.set(props.name, css);\n          }\n          return null;\n        }\n      }\n    });\n    return () => h(\"span\", { class: [\"iconify\", cssClass.value] });\n  }\n});\n","import { Icon as Iconify, addIcon } from \"@iconify/vue\";\nimport { h } from \"vue\";\nimport { initClientBundle, loadIcon, useResolvedName, resolveCustomizeFn } from \"./shared.js\";\nimport { useAsyncData, useNuxtApp, defineComponent, useAppConfig, onServerPrefetch } from \"#imports\";\nexport const NuxtIconSvg = /* @__PURE__ */ defineComponent({\n  name: \"NuxtIconSvg\",\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    customize: {\n      type: [Function, Boolean, null],\n      default: null,\n      required: false\n    }\n  },\n  setup(props, { slots }) {\n    const nuxt = useNuxtApp();\n    const options = useAppConfig().icon;\n    const name = useResolvedName(() => props.name);\n    const storeKey = \"i-\" + name.value;\n    if (name.value) {\n      onServerPrefetch(async () => {\n        if (import.meta.server) {\n          await useAsyncData(\n            storeKey,\n            async () => await loadIcon(name.value, options.fetchTimeout),\n            { deep: false }\n          );\n        }\n      });\n      if (import.meta.client) {\n        const payload = nuxt.payload.data[storeKey];\n        if (payload) {\n          addIcon(name.value, payload);\n        } else {\n          initClientBundle(addIcon);\n        }\n      }\n    }\n    return () => h(Iconify, {\n      icon: name.value,\n      ssr: true,\n      // Iconify uses `customise`, where we expose `customize` for consistency\n      customise: resolveCustomizeFn(props.customize, options.customize)\n    }, slots);\n  }\n});\n","import { computed, defineComponent, h } from \"vue\";\nimport { NuxtIconCss } from \"./css.js\";\nimport { NuxtIconSvg } from \"./svg.js\";\nimport { useResolvedName } from \"./shared.js\";\nimport { useAppConfig, useNuxtApp } from \"#imports\";\nexport default defineComponent({\n  name: \"NuxtIcon\",\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    mode: {\n      type: String,\n      required: false,\n      default: null\n    },\n    size: {\n      type: [Number, String],\n      required: false,\n      default: null\n    },\n    customize: {\n      type: [Function, Boolean, null],\n      default: null,\n      required: false\n    }\n  },\n  setup(props, { slots }) {\n    const nuxtApp = useNuxtApp();\n    const runtimeOptions = useAppConfig().icon;\n    const name = useResolvedName(() => props.name);\n    const component = computed(\n      () => nuxtApp.vueApp?.component(name.value) || ((props.mode || runtimeOptions.mode) === \"svg\" ? NuxtIconSvg : NuxtIconCss)\n    );\n    const style = computed(() => {\n      const size = props.size || runtimeOptions.size;\n      return size ? { fontSize: Number.isNaN(+size) ? size : size + \"px\" } : null;\n    });\n    return () => h(\n      component.value,\n      {\n        ...runtimeOptions.attrs,\n        name: name.value,\n        class: runtimeOptions.class,\n        style: style.value,\n        customize: props.customize\n      },\n      slots\n    );\n  }\n});\n"],"names":["isDefer","dedupe","useAsyncData","args","autoKey","_isAutoKeyNeeded","_key","_handler","options","key","computed","toValue","nuxtApp","useNuxtApp","getDefault","getDefaultCachedData","asyncDataDefaults","initialFetchOptions","_a","createAsyncData","asyncData","initialFetch","promise","getCurrentInstance","onServerPrefetch","asyncReturn","writableComputedRef","args2","clearNuxtDataByKey","asyncDataPromise","getter","value","ref2","keyOrFetcher","fetcher","pick","obj","keys","newObj","initialCachedData","hasCustomGetCachedData","handler","_b","_ref","ref","shallowRef","hasCachedData","unsubRefreshAsyncData","toRef","_opts","newValue","opts","cachedData","resolve","reject","err","_result","result","error","createError","unref","debounce","nextTick","ctx","loadIcon","name","timeout","_icon","_getIcon","timeoutWarn","load","_loadIcon","useResolvedName","getName","useAppConfig","collections","a","b","bare","resolved","collection","c","resolveCustomizeFn","customize","globalCustomize","SYMBOL_SERVER_CSS","escapeCssSelector","selector","NuxtIconCss","defineComponent","props","nuxt","cssClass","getCSS","icon","withLayer","iconSelector","css","getIconCSS","configs","useRuntimeConfig","ssrCSS","useHead","h","NuxtIconSvg","slots","storeKey","Iconify","index","runtimeOptions","component","style","size"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}